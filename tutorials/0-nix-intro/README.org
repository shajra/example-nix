#+TITLE: Nix Introduction
#+SETUPFILE: ../../support/links.org

* Org-mode Setup                                                   :noexport:

  This snippet is just used by Emacs's org-mode to crop down results:

  #+NAME: crop
  #+BEGIN_SRC emacs-lisp :var text="" :var first-n=5 :var last-n=5 :results silent
    (let* ((ls         (split-string text "\n"))
           (first-ls   (-take first-n ls))
           (rest-first (-drop first-n ls))
           (rest-last  (-drop-last (+ 1 last-n) rest-first))
           (last-ls    (-take-last (+ 1 last-n) rest-first)))
      (string-join
       (if rest-last
           (append first-ls '("…") last-ls)
         (append first-ls last-ls))
       "\n"))
  #+END_SRC

  Cleans directory for run:

  #+NAME: nix-init
  #+BEGIN_SRC shell :eval no
    export NIX_PROFILE=$(pwd)/nix-profile
    export NIX_PATH=nixpkgs=$(nix eval --file ../../support/nix nixpkgs.path);
  #+END_SRC

  #+BEGIN_SRC shell :results silent :noweb yes
    <<nix-init>>
    nix-env -e hello
    rm -f result*
    rmdir -rf /tmp/some.d
    mkdir --parents "$NIX_PROFILE"
  #+END_SRC

* Introduction to Nix

  This tutorial illustrates some basic operation of Nix. We'll introduce some
  concepts, terminology, and command-line utilities. Later tutorials will
  illustrate how to build your own projects with Nix and a library provided by
  this project called Pkgs-make.

* Motivation for Nix

  Nix at its core is a package manager that can build from source arbitrary
  packages written in a variety of languages.

  Every programming language ecosystem has its particular set of tools for
  building and managing libraries (for instance, Python has PIP/Conda and Ruby
  has Gems). Reaching for a tool like the Nix package manager may at first seem
  redundant. Two central benefits of Nix are

  - extreme build/deployment reproducibility.
  - ease to compose artifacts from a variety of languages ecosystems

  Many languages use FFI wrapper libraries over native C libraries. Or they
  require oddly-compiled external dependencies for compilation or runtime.
  Projects often don't make clear how to install and configure these
  dependencies reliably.

  Furthermore, some domains like machine learning require the integration of
  different libraries and tools developed in languages like C/C++, R, or
  Python. To maintain reproducibility while integrating such heterogeneous
  builds, we could use something like [[docker][Docker]]. With Docker's Dockerfiles, we
  maintain a script of all the things we need to do to manage dependencies, and
  use that to build an image for development. But Docker introduces a few
  problems.

  One problem with Docker is that Docker images are hard to trust. For
  instance, when we use a “debian:8.7” image from Docker Hub, it's not clear
  how to reproduce it if we have to. We just trust the community to have
  created a reasonable image from some Dockerfile, which is then frozen with a
  version identifier “8.7” and published on Docker Hub. Furthermore, Docker
  makes no guarantee that two images created from the same Dockerfile will be
  equivalent.

  The Nix package manager provides a better architecture for reproducible
  builds by treating the build process as a mathematical function. In Nix,
  these functions are written in a language also called Nix. And as in math,
  Nix expressions yield the same result, even when called at different times or
  on different machines (just as we trust ~1 + 1~ to evaluate to ~2~ on any
  machine at any time).

  To underscore how repeatable and precise Nix builds are, it helps to know
  that Nix uniquely identifies packages by a hash derived from the hashes of
  requisite dependencies and configuration. This is a recursive hash
  calculation that assures that the smallest change to even a distant
  transitive dependency changes the hash. When dependencies are downloaded,
  they are checked against the expected hash. Most Nix projects (this one
  included) are careful to pin dependencies to specific versions/hashes.
  Because of this, when building the same project with Nix on two different
  systems, we get an extremely high confidence we will get the same output,
  often bit-for-bit. This is a profound degree of precision relative to other
  popular package managers.

  Because builds are so deterministic, we can cache them with far more
  precision and resolution than we can with Docker's Dockerfiles. And because
  Nix is based on mathematical functions, there's lots of composition (as in
  ~f°g~), which you can use to mix your C, R, Haskell, and so forth. The
  expressiveness of this composition far exceeds what we can do with
  Dockerfiles.

  Central to Nix is a special Git repository hosted on GitHub called [[nixpkgs][Nix
  Packages (Nixpkgs)]], which is a large tree of Nix expressions for all kinds of
  tools and libraries built from a variety of source languages/platforms
  (enough to support [[nixos][an entire operating system called NixOS]]).

  So once we learn the language of Nix, we can build almost anything we want,
  using Nixpkgs as a starting point. Nix can be very hackable without
  abandoning a principled architecture.

  Nix is not without its problems, as [[gonzalez-critique][Gabriel Gonzalez points out]]. Nix could
  use more documentation and tools to ease adoption. Also though Nix has a
  healthy community of contributors, it still takes a lot of work to curate all
  of Nixpkgs, so you may occasionally find yourself writing your own Nix
  expressions, or contributing back to the Nix ecosystem. Fortunately, once
  you know what you're doing, many Nix expressions are compact and easy to
  modify or override.

  For many of us the benefits of Nix outweigh the inconveniences. Hopefully,
  projects and tutorials like this can help tip the balance further.

* Exploring a Fresh Nix Installation

  By design, Nix sequesters almost all of its installation under =/nix=. This
  way, Nix has extremely few dependencies on the surrounding environment.

  For non-NixOS installations of Nix, if you deleted =/nix=, you would be very
  close to a clean uninstallation. Beyond files in =/nix= an installation may
  also include

  - a few dot-files and symlinks in the home directory of both the root and
    your user account

  - a few Nix-related configuration files under =/etc/nix= for configuring Nix

  - depending on your OS, a script like =/etc/profile.d/nix.sh= or
    =/etc/bashrc= to have interactive shells set up with environment variables
    useful for Nix commands.

  - depending on you OS, files under =/etc/system.d/= (Linux's systemd) or
    =/Library/LaunchDaemons=including (MacOS's launchd) to start up a
    “nix-daemon” service used by Nix commands.

  If you reran the installation script, it would stop if it detected any of
  these files from a previous installation, and would instruct you on how to
  remove them. There's no official uninstallation script, but a huge percentage
  of the installation really is under =/nix=.

  There are two directories under =/nix=:

  - =/nix/store=: where builds are cached and installed

  - =/nix/var=: where mutable metadata, symlinks, caching, and indexing is
    managed.

  Because builds in Nix are expected to be precise and reproducible, when a
  build ends up in =/nix/store=, it is never mutated (though later we'll see
  that it can be removed when detected as no longer used).

  Typically, you'll never manage files under =/nix= directly. Instead you'll
  use the Nix command-line tools. To get packages into =/nix/store= we first
  need a Nix expression. These expressions can either come from a third party
  like the central Nixpkgs GitHub repository. Or we can write our own.

* The Nix Language

  To better discuss the Nix command-line tools and also Nixpkgs, we'll
  introduce the Nix language first. This is no substitute for the [[nix-language][official Nix
  language documentation]], which is surprisingly not that long for a programming
  language. Nix does not have much syntax relative to other general-purpose
  programming languages.

** Primitive literals

   We can play around with the Nix language with the =nix eval= command. As
   with many languages, we can use Nix as a simple calculator by passing Nix
   expressions to it:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(1 + 1)'
   #+END_SRC

   #+RESULTS:
   : 2

   Note, the parentheses are necessary with =nix eval= when passing expressions
   directly on the command-line. The single-quotes are to pass the whole
   parenthesized expression as one argument in a shell invocation. If you want
   less boilerplate (just ~1 + 1~, for example), you can use the =nix repl=
   command for an interactive session.

   Nix supports a variety of types you'd expect for a programming language, and
   we get some literal syntax for typical primitives:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(builtins.typeOf 1)'
     nix eval '(builtins.typeOf 1.0)'
     nix eval '(builtins.typeOf true)'
   #+END_SRC

   #+RESULTS:
   : "int"
   : "float"
   : "bool"

   Though not covered here in great detail, primitives support the typical
   operations one would expect. For instance, we have =||=, =&&=, and =!= for
   boolean values. Numeric values have typical arithmetic operators of =+=,
   =-=, =/=, and =*=. And all values can be compared with ====.

** Strings

   As you may expect from other languages, Nix supports string literals with
   the conventional double quote syntax:

   #+BEGIN_SRC shell :results output :exports both
   nix eval '(builtins.typeOf "hello")' #+END_SRC

   #+RESULTS:
   : "string"

   Nix also supports multi-line strings with two consecutive single quotes:

   #+BEGIN_SRC shell :results output :exports both
   nix eval "('' line 1 line 2 line 3 '')" #+END_SRC

   #+RESULTS:
   : " line 1\n   line 2\nline 3\n"

   The left-most token in any line establishes a left margin. In the example
   above, this is “line 3”. Beyond these strings, Nix does not have
   syntactically significant whitespace.

   We concatenate strings with the =+= operator:

   #+BEGIN_SRC shell :results output :exports both
   nix eval '("a" + "b")' #+END_SRC

   #+RESULTS:
   : "ab"

** Let-expressions

   For the most part, Nix is a lazily evaluated purely functional programming
   language. We don't imperatively run commands that change things, and in
   general, the language restricts us from doing so. There's not even syntax to
   do so. At the top-level, you can't bind values to variables as you may in
   other imperative languages. Instead, we are only ever working with a single
   Nix expression at a time, and we bind values to names locally with
   /let-expressions/:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(let a = 1; b = 2; in a + b)'
   #+END_SRC

   #+RESULTS:
   : 3

   Note that semicolons are mandatory in all Nix forms that have them,
   including let-expressions. Because of Nix's strict parsing you can neither
   elide semicolons, nor put extra ones.

** String interpolation

   Sometimes we build up small code snippets inline in a Nix expression, so
   it's useful to have string interpolation support. This is done with the
   following syntax:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(
         let foo = "Foo";
             bar = "Bar";
         in "${foo + bar} is a terrible name")'
   #+END_SRC

   #+RESULTS:
   : "FooBar is a terrible name"

   String interpolation is supported by both normal and multi-line strings.

   You can only interpolate strings into strings. For instance, interpolating
   an integer won't work:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(
         let a_number = 42;
         in "${a_number} is a terrible number")' 2>&1 || true
   #+END_SRC

   #+RESULTS:
   : error: cannot coerce an integer to a string, at (string):3:9

   Note that unlike shell scripts, the curly braces are not optional for string
   interpolation in Nix. This works out in our favor if we're writing shell
   scripts inline in a Nix expression, because we can use ~$name~ for shell
   string interpolation and ~${nix_expr}~ for Nix string interpolation. If this
   is not enough, though not covered in this tutorial, there is a syntax for
   suppressing interpolation in both normal and multi-line Nix string literals.

** Functions

   Nix has first class functions. Functions take in only one argument at a
   time, and use a colon to separate the parameter name from the body of the
   function. Furthermore, Nix uses whitespace for function application:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(builtins.typeOf (a: a + 1))'
     nix eval '((a: a + 1) 2)'
   #+END_SRC

   #+RESULTS:
   : "lambda"
   : 3

   Since functions take only one argument at a time, we encode n-ary functions
   with functions returning functions:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '((a: b: a + b) 1 2)'
   #+END_SRC

   #+RESULTS:
   : 3

   In this case, when we apply ~1~ to ~a: b: a + b~, we get another function.
   When we apply ~2~ to this resultant function, we finally get our answer ~3~.

   If you've heard of /currying a function/ in other languages with n-ary
   functions, you may recognize this technique.

** Lists

   Nix also has list literals which use square brackets and are
   whitespace-delimited:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(builtins.typeOf [1 2 3 4 5])'
   #+END_SRC

   #+RESULTS:
   : "list"

   We can append lists together with the =++= operator:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '([1 2] ++ [3 4])'
   #+END_SRC

   #+RESULTS:
   : [ 1 2 3 4 ]

   The elements of a list in Nix do not have to be the same type, and lists can
   be nested:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '([1 "hello" [true]])'
   #+END_SRC

   #+RESULTS:
   : [ 1 "hello" [ true ] ]

** Attribute sets

   Very importantly, Nix has a kind of map called an /attribute set/ that is
   specialized to have textual indices called /attributes/ that index values of
   arbitrary types. It uses the following syntax:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(builtins.typeOf { foo = 1; bar = 2; })'
     nix eval '({ foo = 1; bar = 2; }.bar)'
   #+END_SRC

   #+RESULTS:
   : "set"
   : 2

   Note, =builtins= is just an attribute set that is in scope by default. And
   =typeOf= is just an attribute that maps to a function that returns a string
   indicating the type of the argument.

   Often used in Nix expressions, we can overlay sets on top of each other with
   the =//= operator:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '({ foo = 1; bar = 2; } // { bar = 3; baz = 4; })'
   #+END_SRC

   #+RESULTS:
   : { bar = 3; baz = 4; foo = 1; }

   Additionally, we can prefix set literals with the =rec= keyword to get
   recursive sets. Recursive sets allow values in a set to reference attributes
   by name:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(rec { foo = bar; bar = 2; }.foo)'
   #+END_SRC

   #+RESULTS:
   : 2

   Without the =rec= keyword, we'd get an error:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '({ foo = bar; bar = 2; }.foo)' 2>&1 || true
   #+END_SRC

   #+RESULTS:
   : error: undefined variable 'bar' at (string):1:10

   If a function accepts an attribute set as an argument, we can have Nix
   destructure the set as a convenience with the following pattern syntax:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(({ foo, bar }: foo + bar ) { foo = 1; bar = 2; })'
   #+END_SRC

   #+RESULTS:
   : 3

   This basic pattern syntax is rigid, and we can't pass in a attribute set
   with attributes that don't match the pattern:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(({ foo }: foo + 2 ) { foo = 3; bar = 4; })' 2>&1 || true
   #+END_SRC

   #+RESULTS:
   : error: anonymous function at (string):1:3 called with unexpected argument 'bar', at (string):1:2

   If we want to relax the destructuring to accept sets with other attributes
   we can use a “...” form:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(({ foo, ...}: foo + 2 ) { foo = 3; bar = 4; })'
   #+END_SRC

   #+RESULTS:
   : 5

   When destructuring, we can still bind the whole set to a name if we want to
   using a “@” form.

   #+BEGIN_SRC shell :results output :exports both
     nix eval '((s@{ foo, bar }: foo + s.bar ) { foo = 2; bar = 3; })'
   #+END_SRC

   #+RESULTS:
   : 5

   Attribute sets also support an additional syntactic convenience when pulling
   in locally bound values as attributes, which comes up a lot in Nix. For
   example, consider the way we're using ~a = a~ here:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(let a = 3; in { a = a; })'
   #+END_SRC

   #+RESULTS:
   : { a = 3; }

   Rather than worrying about spelling the same name correctly both sides of
   the ‘=’ for an attribute setting, we can use the =inherit= keyword:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(let a = 3; in { inherit a; })'
   #+END_SRC

   #+RESULTS:
   : { a = 3; }

** Paths

   Because the Nix language is domain-specific for building packages, paths
   come up frequently in Nix expressions. Nix conveniently has a /path/ type,
   which is indicated by identifiers with at least one slash:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(builtins.typeOf /some/filepath)'
     nix eval '(/some/filepath)'
   #+END_SRC

   #+RESULTS:
   : "path"
   : /some/filepath

   As part of a standard Nix installation, there's a special environment
   variable =NIX_PATH= that makes paths dynamically available to Nix
   expressions.

   As with =PATH=, the settings within =NIX_PATH= are colon-delimited, with
   earlier settings taking precedence over later ones. There are two forms for
   setting =NIX_PATH=:

   - ~<name>=<filepath>~
   - ~<filepath>~

   In a Nix expression, we can use an angle bracket syntax to search =NIX_PATH=
   for an existent file path. Here's an example of using =NIX_PATH= to set the
   name “temporary” to =/tmp=, which we then access with ~<temporary>~:

   #+BEGIN_SRC shell :results output :exports both
     NIX_PATH=temporary=/tmp nix eval '(<temporary>)'
   #+END_SRC

   #+RESULTS:
   : /tmp

   If we create some directories there:

   #+BEGIN_SRC shell :results silent
     mkdir --parents /tmp/some.d/path
   #+END_SRC

   Then we can access them using our name as a path prefix in our angle
   brackets:

   #+BEGIN_SRC shell :results output :exports both
     NIX_PATH=temporary=/tmp nix eval '(<temporary/some.d/path>)'
   #+END_SRC

   #+RESULTS:
   : /tmp/some.d/path

   If we use the second form for =NIX_PATH=, we can specify directories without
   a name. These directories are then used as candidate prefixes until an
   existent path if found. For example, we can consider =/tmp= as a path prefix
   when looking up =some.d/path= to find =/tmp/some.d/path=:

   #+BEGIN_SRC shell :results output :exports both
     NIX_PATH=/tmp nix eval '(<some.d/path>)'
   #+END_SRC

   #+RESULTS:
   : /tmp/some.d/path

   Remember that a major motivation for using Nix is for deterministic builds.
   The angle bracket syntax threatens to break reproducibility from system to
   system (we can't control what =NIX_PATH= will be set to in arbitrary
   environments). So if we use angle brackets at all, we have to be careful.

   The Nix installation normally configures =NIX_PATH= for shells (for
   instance, via =/etc/profile.d/nix.sh= for systems with =/etc/profile.d=).
   This configuration should allow you to access a snapshot of Nixpkgs with
   ~<nixpkgs>~. For example, you might see =NIX_PATH= set up for use like this:

   #+BEGIN_SRC shell :eval no
     env | grep NIX_PATH
     nix eval '(<nixpkgs>)'
   #+END_SRC

   #+RESULTS:
   : NIX_PATH=/nix/var/nix/profiles/per-user/root/channels
   : /nix/var/nix/profiles/per-user/root/channels/nixpkgs

** Importing

   We can import paths. If the path is a file, it's loaded as a Nix expression.
   If it's a directory, a file called “default.nix” is loaded within it.

   The Nixpkgs source code, for example, has a =default.nix= file at its root,
   so we can import a path directly to it:

   #+BEGIN_SRC shell :results output :exports both
     nix eval '(builtins.typeOf (import <nixpkgs>))'
   #+END_SRC

   #+RESULTS:
   : "lambda"

   We see here that Nixpkgs is a function. We'll talk more about the nature of
   the Nixpkgs function next.

* Nixpkgs and Building

  As mentioned earlier, Nixpkgs is a repository of useful Nix expressions
  broadly referenced by expressions in the Nix ecosystem.

  Nixpkgs is a function that takes an attribute set as configuration and
  returns a nested attribute set containing thousands of packages and
  functions. An empty attribute set passed to the Nixpkgs function configures
  it with defaults:

  #+BEGIN_SRC shell :results output :exports both
    nix eval '(builtins.typeOf (import <nixpkgs> {}))'
  #+END_SRC

  #+RESULTS:
  : "set"

  One of the packages in Nixpkgs is the [[hello][GNU Hello]] program. The Nix expression
  that builds it is mapped to the attribute =hello=:

  #+BEGIN_SRC shell :results output :exports both
    nix eval '(builtins.typeOf (import <nixpkgs> {}).hello)'
  #+END_SRC

  #+RESULTS:
  : "set"

  At this point, packages in Nixpkgs appear to just be attribute sets, but
  there's a special schema for attributes in a set that allow various Nix
  command-line utilities to recognize the set as a /derivation/ for a package.

  For these derivation sets, we can use the =nix show-derivation= command to
  view some metadate about how it's respective package will be built.
  For instance, here we use =nix show-derivation= to inspect Nixpkg's
  derivation for GNU Hello:

  #+BEGIN_SRC shell :results output :exports both :post crop(text=*this*)
    nix show-derivation '((import <nixpkgs> {}).hello)'
  #+END_SRC

  #+RESULTS:
  #+begin_example
  {
    "/nix/store/v2l3ncp0ypdssjf7b8rxyppn3kyq3w87-hello-2.10.drv": {
      "outputs": {
        "out": {
          "path": "/nix/store/58r35bqb4f3lxbnbabq718svq9i2pda3-hello-2.10"
  …
        "system": "x86_64-linux",
        "version": "2.10"
      }
    }
  }
  #+end_example

  We've cropped the details of the derivation above, but you can get a sense
  that the derivation when evaluated is cached into =/nix/store= as a “*.drv”
  file, and when the application is actually built it's put in another output
  path, also in =/nix/store=.

  Also important to know, when we interpolate a derivation into a string, we
  inject as a string the path of the derivation's output:

  #+BEGIN_SRC shell :results output :exports both
    nix eval '("our value is ${(import <nixpkgs> {}).hello}")'
  #+END_SRC

  #+RESULTS:
  : "our value is /nix/store/58r35bqb4f3lxbnbabq718svq9i2pda3-hello-2.10"

  Note, that it may not exist there yet. We can build it with a call to =nix
  build=:

  #+BEGIN_SRC shell :results output :exports both
    nix build --verbose '((import <nixpkgs> {}).hello)' 2>&1
  #+END_SRC

  #+RESULTS:
  : copying path '/nix/store/58r35bqb4f3lxbnbabq718svq9i2pda3-hello-2.10' from 'https://cache.nixos.org'...

  If we were to dig into the Nixpkgs repository, we'd find [[nixpkgs-hello][code for building
  Hello from source]]. But notice that we didn't end up fetching the Hello
  released tarball, unpacking it, and building it. Instead, we got a cached
  version of it from https://cache.nixos.org.

  The Nix community builds and caches packages from Nixpkgs in a service called
  [[hydra][Hydra]], which https://cache.nixos.org fronts. If Hydra has the build you're
  trying to build, it's pulled down and cached locally in =/nix/store=.
  Otherwise, everything is built from source and cached in =/nix/store=.

  You've probably also noticed the hashes in names of =/nix/store='s contents.
  Nix meticulously hashes the contents of all the inputs for any package's
  derivation. If a single bit of the input changes, then the resultant hash
  will be different. This is what gives us confidence that the artifacts built
  by Hydra are more or less the same as what we'd have built locally.

  =nix build= leaves behind a “result” symlink in the current directory for our
  convenience so we don't have to figure out how to find our build in
  =/nix/store=:

  #+BEGIN_SRC shell :results output :exports results
    tree -L 2 result | sed -e "s|result|result -> $(readlink result)|"
  #+END_SRC

  #+RESULTS:
  : result -> /nix/store/58r35bqb4f3lxbnbabq718svq9i2pda3-hello-2.10
  : ├── bin
  : │   └── hello
  : └── share
  :     ├── info
  :     ├── locale
  :     └── man
  :
  : 5 directories, 1 file

  =nix build= also supports a =--no-link= switch if we want to build without
  leaving behind this “result” symlink.

* Calling =nix=

  We've shown thus far that Nix expressions can be passed to some commands of
  the =nix= utility but must be surrounded by parentheses. Such commands
  include =nix eval=, =nix show-direction=, and =nix build=. These commands
  accept /installables/ as positional arguments. Installables are either Nix
  expressions (in which case they are surrounded by parentheses), or they are
  attribute paths to select a derivation from an attribute set. By default,
  this set for selecting from is built from an interpretation of =NIX_PATH=.
  We'll next discuss the nature of that interpretation.

  As discussed earlier in the tutorial, =NIX_PATH= can have entries of two
  forms:

  - ~<name>=<filepath>~
  - ~<filepath>~

  Consider the following setting of the =NIX_PATH= with the first form of an
  explicitly named path:

  #+BEGIN_SRC shell :eval no
    NIX_PATH=nixpkgs=/path/to/some-nixpkgs-clone
  #+END_SRC

  With this setting of =NIX_PATH=, the set that =nix= would use to select an
  installable from would be:

  #+BEGIN_SRC nix :eval no
    {
      nixpkgs =
        let p = import /path/to/some-nixpkgs-clone
        in
          if builtins.typeOf p == "lambda"
          then p {}
          else p;
    }
  #+END_SRC

  Note that =nix= automatically applies the empty set to any function that's
  detected when imported.

  Now consider if =NIX_PATH= were set with the second form of just a path as
  follows:

  #+BEGIN_SRC shell :eval no
    NIX_PATH=/some/path
  #+END_SRC

  This path would be interpreted as a nonempty set only if both the files
  =/some/path/manifest.nix= and =/some/path/nixpkgs/default.nix= exist:

  #+BEGIN_EXAMPLE
    /some/path
    ├── manifest.nix
    └── nixpkgs
        └── default.nix
  #+END_EXAMPLE

  Then =NIX_PATH= would be interpreted as the following set:

  #+BEGIN_SRC nix :eval no
    {
      nixpkgs =
        let p = import /some/path/nixpkgs/default.nix
        in
          if builtins.typeOf p == "lambda"
          then p {}
          else p;
    }
  #+END_SRC

  If =NIX_PATH= has multiple values (colon-delimited), then each setting is
  considered in order until one provides an installable to be selected.

  If you feel this algorithm seems somewhat confusing, you're not alone, and
  it's going to change in a yet-unreleased 2.4 version of Nix. The current way
  that =NIX_PATH= is used to build a set for selecting installables differs
  from how =NIX_PATH= is used to look up paths with the angle bracket syntax in
  a Nix expression. This incongruence can be confusing.

  Complexities aside, now that we know how some =nix= commands select
  installables from =NIX_PATH=, we can select out a derivation to build with
  the following concise call:

  #+BEGIN_SRC shell :results silent
    nix build nixpkgs.hello
  #+END_SRC

  The installation of Nix by default sets up =NIX_PATH= to enable this concise
  call (the interpreted set should have at least a "nixpkgs" attribute).
  This concision is hopefully an appreciated an improvement over selecting
  installables using the angle bracket syntax in an expression:

  #+BEGIN_SRC shell :results silent
    nix build '((import <nixpkgs> {}).hello)'
  #+END_SRC

  For =nix= commands that select installables, If we don't want to select them
  from =NIX_PATH= at all, we can use the =--file= switch to specify explicitly
  a path to be imported and select attributes from.

* Finding Packages

  We took for granted above that Nixpkgs had a package on the =hello=
  attribute.

  We can find programs in Nix with a =nix search= invocation:

  #+BEGIN_SRC shell :eval no
    nix search --update-cache hello
  #+END_SRC

  #+BEGIN_SRC shell :results output :exports results :noweb strip-export
    <<nix-init>> nix search --no-cache hello | ansifilter
  #+END_SRC

  #+RESULTS:
  #+begin_example
  ,* nixpkgs.gnome3.iagno (iagno-3.34.5)
    Computer version of the game Reversi, more popularly called Othello

  ,* nixpkgs.hello (hello)
    A program that produces a familiar, friendly greeting

  ,* nixpkgs.hello-unfree (example-unfree-package-1.0)
    An example package with unfree license (for testing)

  ,* nixpkgs.javaPackages.mavenHello_1_0 (maven-hello)
    Maven Hello World

  ,* nixpkgs.javaPackages.mavenHello_1_1 (maven-hello)
    Maven Hello World

  #+end_example

  The output of =nix search= is formatted as

  #+BEGIN_EXAMPLE
    ,* attribute-name (name-of-package)
      Short description of package
  #+END_EXAMPLE

  By default, =nix search= searches =NIX_PATH= to find all the attribute paths
  that can be selected as an installable as described in the previous section.
  This can take a while, so =nix search= by default uses a cache. This cache
  starts out empty, so at first =nix search= will return no results. But we can
  use the =--update-cache= flag to populate the cache, which might take a some
  time. After that we can stop using the =--update-cache= flag to quickly
  search cached results. If the cache gets stale, we can update it again.

  =nix search= also supports a =--file= option to search a single Nix
  expression, rather than everything in =NIX_PATH=. But if you use this option
  you may be surprised when you get results from what's cache instead of the
  Nix file specified. So usage of =--file= is recommended to be paired with
  =--no-cache=, which bypasses the cache. Often times searching a single Nix
  expression with =--file= is much faster than searching all of =NIX_PATH=.
  It's recommended to reserve the cache for just caching your =NIX_PATH=
  searches, rather than using =--file= and =--update-cache= together to cache
  the search results of a single Nix file.

* Running

  If you've never run the GNU Hello program, it's not too interesting. It's
  just a small C program useful for tutorials like this. We can run it using
  the “result” symlink left behind by an invocation of =nix build=:

  #+BEGIN_SRC shell :results output :exports both
    result/bin/hello
  #+END_SRC

  #+RESULTS:
  : Hello, world!

  Or we can also run it directly without the symlink using =nix run=:

  #+BEGIN_SRC shell :results output :exports both
    nix run nixpkgs.hello --command hello
  #+END_SRC

  #+RESULTS:
  : Hello, world!

  This invocation makes an environment in which we have the =bin= directory of
  the =nixpkgs.hello= package on our path (we can put other packages as well).
  The call then runs the command after the =--command= switch. See ~nix run
  --help~ for more information.

* Installing and Uninstalling Programs

  We've seen that we can build programs with =nix build= and then execute
  programs using the "result" symlink (=result/bin/*=). Additionally, we've
  seen that you can run programs with =nix run=. But these additional steps
  and switches/arguments can feel extraneous. It would be nice if we could
  just have the programs on our =PATH=. This is what =nix-env= is for.

  =nix-env= maintains a symlink tree, called a /profile/, of installed
  programs. The active profile is pointed to by a symlink at =~/.nix-profile=.
  By default, this profile points to
  =/nix/var/nix/profiles/per-user/$USER/profile=. But you can point your
  =~/.nix-profile= to any writable location with the =--switch-profile=
  switch:

  #+BEGIN_SRC shell :eval no
    nix-env --switch-profile /nix/var/nix/profiles/per-user/$USER/another-profile
  #+END_SRC

  This way, you can just put =~/.nix-profile/bin= on your =PATH=, and any
  programs installed in your currently active profile will be available for
  interactive use or scripts.

  We can query what's installed in the active profile with the =--query=
  switch:

  #+BEGIN_SRC shell :eval no
    nix-env --query
  #+END_SRC

  Presuming Nixpkgs is set up on our =NIX_PATH=, we can install the
  =nixpkgs.hello= installable with the =--install= switch:

  #+BEGIN_SRC shell :results output :exports both :noweb strip-export
    <<nix-init>> nix-env --install --attr nixpkgs.hello 2>&1
  #+END_SRC

  #+RESULTS:
  : installing 'hello-2.10'
  : building '/nix/store/a8nhy6xm3jybv323nrirzkpbbgmc2shp-user-environment.drv'...
  : created 2 symlinks in user environment

  We can see this installation by querying what's been installed:

  #+BEGIN_SRC shell :results output :exports both :noweb strip-export
    <<nix-init>> nix-env --query
  #+END_SRC

  #+RESULTS:
  : hello-2.10

  And if we want to uninstall a program from our active profile, we do so by
  its name, in this case "hello-2.10", or we could use its short name of just
  "hello".

  #+BEGIN_SRC shell :results output :exports both :noweb yes
    <<nix-init>> nix-env --uninstall hello 2>&1
  #+END_SRC

  #+RESULTS:
  : uninstalling 'hello-2.10'

  Note that we've installed GNU Hello using its installable name
  =nixpkgs.hello=, but uninstalled it with it's package name

  =nixpkgs.hello=
  ({{{package-attr}}}) within the referenced Nix expression. But we uninstall
  it using the package name ({{{package-name}}}), which may or may not be the
  same as the attribute name. When a package is installed, Nix keeps no
  reference to the expression that evaluated to the derivation of the
  installed package. The attribute name is only relevant to this expression.
  In fact, two different expressions could evaluate to the exact same
  derivation, but use different attribute names. This is why we uninstall
  packages by their package name.

  See the [[nix-env][documentation for =nix-env=]] for more details.


  # TODO: Probably delete everything below in this section

  =~/.nix-profile= is a symlink that follows to a /profile/ under
  =/nix/var/nix/profiles= managed by =nix-env=. The profile furthermore points
  to an aggregated symlink tree of various programs installed into the profile
  by =nix-env=, often called an /environment/ (though a very overloaded term).
  Programs installed by =nix-env= are made available to us by putting
  =~/.nix-profile/bin= on our =PATH=.

  For example, with our =PATH= set up the following invocation of =nix-env=
  installs the Hello application so we can call it directly, rather than
  calling it via a “result” symlink or a =nix run= invocation:

  #+BEGIN_SRC shell :results output :exports both
    nix-env --install --attr nixpkgs.hello 2>&1
  #+END_SRC

  #+RESULTS:
  : installing 'hello-2.10'
  : building '/nix/store/lwf6zfhyvaxw7g5zjpnbv8rcrq2rvdqn-user-environment.drv'...
  : created 307 symlinks in user environment

  #+BEGIN_SRC shell :exports both
    which hello
  #+END_SRC

  #+RESULTS:
  : /home/shajra/.nix-profile/bin/hello

  We can query with =nix-env= to see what's in our profile:

  #+BEGIN_SRC shell :results output :exports both
    nix-env --query | grep hello
  #+END_SRC

  #+RESULTS:
  : hello-2.10

  Every time we install an application with =nix-env= a new environment symlink
  tree is created in =/nix/store=. For posterity, =nix-env= keeps references to
  old versions under =/nix/var/nix/profiles=. You can use switches like
  =--rollback= with =nix-env= to revert back to previous states. See =nix-env
  --help= for more.

* Uninstalling

  If you no longer want an installed application in your profile, you can
  uninstall it with =nix-env= as well:

  #+BEGIN_SRC shell :exports both
    nix-env --uninstall hello 2>&1
  #+END_SRC

  #+RESULTS:
  : uninstalling 'hello-2.10'

  #+BEGIN_SRC shell :exports both
    which hello || true
  #+END_SRC

  #+RESULTS:
  : hello not found

* Inspecting Dependencies

  To find dependencies of a built package, Nix literally scans all files in a
  package (text and even binary) looking for textual references to
  “/nix/store/…”.

  This makes it easy for Nix to find exactly what's needed for any compiled
  artifact to run. These references are often automated by Nix's tooling and
  library support, and it is generally considered a defect if a required
  runtime dependency is missing a reference point back to =/nix/store=.

  This is important, because it allows for different compilations to rely on
  different versions of dependencies without conflicts. Our application
  shouldn't break if we do something like upgrade our host operating system.

  Also, without this clear and reliable method to detect dependencies, garbage
  collection wouldn't know how to keep needed dependencies around.

  If we're curious about all the dependencies, we can use =nix path-info= to
  list them out.

  #+BEGIN_SRC shell :results output :exports both
    nix path-info --recursive --closure-size nixpkgs.hello \
        | sort --numeric-sort --key 2
  #+END_SRC

  #+RESULTS:
  : /nix/store/dp7i2xjbmmgn5r69jh7iiw57z54nnn6h-libunistring-0.9.10     1634416
  : /nix/store/fwrhy0xaxzm2fp3fh29939n529vi7dxz-libidn2-2.3.0           1857088
  : /nix/store/aqq6367snc1zh3fs1pc4j4zm5h80vkkz-glibc-2.31             32966032
  : /nix/store/rg0pr6ddfsigm516lc2i1xwg5ksg12ff-hello-2.10             33172000

  Hello doesn't rely on much. In real-world programs the dependencies can add
  up.

* Cleaning Up

  Every time you build a new version of your code, it's stored in =/nix/store=.
  There is a command called =nix-collect-garbage= that purges unneeded
  packages. What keeps a package from being reclaimed by =nix-collect-garbage=
  are symlinks under =/nix/var/nix/gcroots=. These come in a few flavors
  including:

  - indirect links to the “result*” links invocations like =nix build= may
    leave on our system

  - links to the currently active =nix-env= environment, as well as all previous
    generations saved away for posterity under =/nix/var/nix/profiles=.

  If you delete a “result*” link and call =nix-collect-garbage=, though some
  garbage may be reclaimed, you may find that an old =nix-env= environment is
  keeping the program alive. We can illustrate this here:

  First, we'll do two =nix-collect-garbage= calls to show that we've reclaimed
  as much space as we can:

  #+BEGIN_SRC shell :results output :exports both
    nix-collect-garbage; nix-collect-garbage
  #+END_SRC

  #+RESULTS:
  : 0 store paths deleted, 0.00 MiB freed
  : 0 store paths deleted, 0.00 MiB freed

  Then we can try to delete our symlink, but another garbage collection doesn't
  doesn't reclaim anything more:

  #+BEGIN_SRC shell :results output :exports both
    rm result
    nix-collect-garbage 2>&1
  #+END_SRC

  #+RESULTS:
  : finding garbage collector roots...
  : removing stale link from '/nix/var/nix/gcroots/auto/3zvhwd2faawz9xbnnr2p4b20q1z86z81' to '/home/shajra/src/shajra/nix-package/tutorials/0-nix-intro/result'
  : deleting garbage...
  : deleting '/nix/store/trash'
  : deleting unused links...
  : note: currently hard linking saves -17.39 MiB
  : 0 store paths deleted, 0.00 MiB freed

  Now with the =--delete-generations= switch of =nix-env= we can delete old
  generations of our environment:

  #+BEGIN_SRC shell :results output :exports both
    nix-env --delete-generations old 2>&1
  #+END_SRC

  #+RESULTS:
  : removing generation 251
  : removing generation 252

  And then then garbage collection works as you'd expect:

  #+BEGIN_SRC shell :results output :exports both
    rm result
    nix-collect-garbage 2>&1
  #+END_SRC

  #+RESULTS:
  #+begin_example
  finding garbage collector roots...
  deleting garbage...
  deleting '/nix/store/gb2kq41xf2rv8gy3cx0fkwz49yv5gcsl-user-environment'
  deleting '/nix/store/lwf6zfhyvaxw7g5zjpnbv8rcrq2rvdqn-user-environment.drv'
  deleting '/nix/store/arqc85rvysw5yjlb9gbvi1pwvap9a95f-env-manifest.nix'
  deleting '/nix/store/58r35bqb4f3lxbnbabq718svq9i2pda3-hello-2.10'
  deleting '/nix/store/v2l3ncp0ypdssjf7b8rxyppn3kyq3w87-hello-2.10.drv'
  deleting '/nix/store/13jqqk547i2hn3899zf2nq9nnn94b7sy-hello-2.10.tar.gz.drv'
  deleting '/nix/store/trash'
  deleting unused links...
  note: currently hard linking saves -17.39 MiB
  6 store paths deleted, 1.43 MiB freed
  #+end_example

* Developing with =nix-shell=

  When Nix builds a derivation, it sets up a clean and controlled environment
  in which to do the build. Thus far, we've not inspected how =nix build=
  works. Nix comes with a =nix-shell= utility that allows us to get the
  environment variables that would be set up for a build. For instance, to get
  into the environment used to build Hello, we could use =nix-shell= as
  follows:

  #+BEGIN_SRC shell :eval no
    nix-shell --expr 'import <nixpkgs> {}' --attr hello
  #+END_SRC

  This drops us into a bash shell we can use interactively. We can also use
  nix-shell with a =--run= switch to run a single command non-interactively
  Additionally, we can use the =--pure= switch to throw away the previous
  environment variables rather than overlay changes on top of them.

  Here's a small example:

  #+BEGIN_SRC shell :results output :exports both :post crop(text=*this*)
    nix-shell --pure --expr 'import <nixpkgs> {}' --attr hello --run 'env'
  #+END_SRC

  #+RESULTS:
  #+begin_example
  WINDRES=windres
  propagatedBuildInputs=
  stdenv=/nix/store/i6vl5lwlz5jbkg4r6p340dwmj6fha3xq-stdenv-linux
  __ETC_PROFILE_SOURCED=1
  DISPLAY=:0
  …
  SIZE=size
  nativeBuildInputs=
  LD=ld
  depsTargetTargetPropagated=
  _=/nix/store/wm8va53fh5158ipi0ic9gir64hrvqv1z-coreutils-8.29/bin/env
  #+end_example

  We're using =--expr= to pass expressions directly to the command line.
  Without this switch, =nix-shell= looks for a =shell.nix= file to import in
  the current working directory. If that's not found, it looks for
  =default.nix=. Otherwise, a file can be passed as a positional parameter.

  =nix-shell= is great for the following two scenarios, which we'll explore in
  later tutorials:

  - debugging a Nix build/derivation

  - entering into a development environment for a project.

  In our derivations we can include as build dependencies not only things like
  compilers that we absolutely need for a build, but also optional tools for
  developer conveniences. This means that with =nix-shell=, we have different
  tools installed per-project, rather than worrying about having the right tool
  installed at a system- or user-level.

* Org-mode Cleanup                                                 :noexport:

  Cleans directory for run

  #+BEGIN_SRC shell :results silent :noweb yes
    <<nix-init>>
    nix-env -e hello
    rm -f result*
    rm -rf /tmp/some.d
    rm -rf "$NIX_PROFILE"
  #+END_SRC

  # Local Variables:
  # org-confirm-babel-evaluate: nil
  # End:
